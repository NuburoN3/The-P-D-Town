<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Dojo Town</title>
  <style>
    body {
      margin: 0;
      background: #0f1720;
      overflow: hidden;
   }

    canvas {
      display: block;
      margin: auto;
image-rendering: pixelated;
      background: #a7d9a8;
    }
  </style>
</head>
<body>
  <canvas id="game" width="640" height="480"></canvas>
 <script>
    const canvas = document.getElementById("game");
    const ctx = canvas.getContext("2d");

    const TILE = 32;

    const gameFlags = {
      acceptedTraining: false,
      completedTraining: false
    };

    const playerInventory = {};

    const playerStats = {
      disciplineLevel: 1,
      disciplineXP: 0,
      disciplineXPNeeded: 10
    };

    const trainingPopup = {
      active: false,
      startedAt: 0,
      durationMs: 2000,
      startXP: 0,
      targetXP: 0,
      xpGained: 0,
      xpNeededSnapshot: 0,
      animDurationMs: 400,
      levelUp: false,
      levelUpHoldMs: 250,
      pendingLevelUpDialogueAt: null
    };

    // 0 grass, 1 path, 2 tree, 3 dojo/wall, 4 signpost, 5 door, 6 interior floor, 7 training floor
    const OVERWORLD_W = 30;
    const OVERWORLD_H = 30;

    const overworldMap = Array.from({ length: OVERWORLD_H }, (_, y) =>
      Array.from({ length: OVERWORLD_W }, (_, x) => {
        if (x === 0 || y === 0 || x === OVERWORLD_W - 1 || y === OVERWORLD_H - 1) return 2;
        return 0;
      })
    );

    const pathX = 15;
    for (let y = 2; y < OVERWORLD_H - 2; y++) {
      overworldMap[y][pathX] = 1;
    }

    for (let x = 8; x <= 22; x++) {
      overworldMap[15][x] = 1;
    }

    const dojoTop = 10;
    const dojoLeft = 13;
    const dojoW = 5;
    const dojoH = 4;

    for (let y = dojoTop; y < dojoTop + dojoH; y++) {
      for (let x = dojoLeft; x < dojoLeft + dojoW; x++) {
        overworldMap[y][x] = 3;
      }
    }

    const overworldDoor = { x: dojoLeft + Math.floor(dojoW / 2), y: dojoTop + dojoH - 1 };
    overworldMap[overworldDoor.y][overworldDoor.x] = 5;

    overworldMap[14][14] = 4;

    const treeClusters = [
      [4, 4], [5, 4], [4, 5], [24, 4], [25, 4], [24, 5],
      [5, 23], [4, 24], [24, 23], [25, 24], [22, 20], [8, 20]
    ];
    for (const [x, y] of treeClusters) {
      overworldMap[y][x] = 2;
    }

    const INTERIOR_W = 12;
    const INTERIOR_H = 10;
    const interiorMap = Array.from({ length: INTERIOR_H }, (_, y) =>
      Array.from({ length: INTERIOR_W }, (_, x) => {
        if (x === 0 || y === 0 || x === INTERIOR_W - 1 || y === INTERIOR_H - 1) return 3;
        return 6;
      })
    );

    const interiorDoor = { x: Math.floor(INTERIOR_W / 2), y: INTERIOR_H - 1 };
    interiorMap[interiorDoor.y][interiorDoor.x] = 5;

    const trainingTile = { x: 4, y: 5 };
    interiorMap[trainingTile.y][trainingTile.x] = 7;

    // NPC entities are separate from map tiles.
    const npcs = [
      {
        world: "interior",
        x: 7 * TILE,
        y: 4 * TILE,
        width: TILE,
        height: TILE,
        name: "Mr. Hanami",
        dialogue: ["Hello there!", "Welcome to the dojo.", "I train students here", "where they practice Hana Sakura style Karate", "which means \"the way of the cherry blossom\".", "Would you like me to teach you?"],
        alreadyTrainingDialogue: "Your training has already begun. Focus your mind.",
        hasTrainingChoice: true
 }
    ];

    const keys = {};
    let interactPressed = false;
   let previousWorldState = "overworld";

    function playerTilePosition() {
      return {
        x: Math.floor((player.x + TILE / 2) / TILE),
        y: Math.floor((player.y + TILE / 2) / TILE)
      };
    }

    function tryTrainingAction() {
      const isFreeExploreState = gameState === "overworld" || gameState === "interior";
      if (!isFreeExploreState) return;
      if (isDialogueActive() || choiceState.active || doorSequence.active) return;
      if (worldName !== "interior") return;
      if (!gameFlags.acceptedTraining) return;

      const tilePos = playerTilePosition();
      const onTrainingTile = tilePos.x === trainingTile.x && tilePos.y === trainingTile.y;
      if (!onTrainingTile) return;

      if (playerStats.disciplineLevel >= 2) {
        showDialogue("", "Training complete. Speak to Mr. Hanami.");
        return;
      }

      const startXP = playerStats.disciplineXP;
      const xpEarned = 5;
      trainingPopup.xpNeededSnapshot = playerStats.disciplineXPNeeded;

      playerStats.disciplineXP += xpEarned;

      trainingPopup.startXP = startXP;
      trainingPopup.targetXP = playerStats.disciplineXP;
      trainingPopup.xpGained = xpEarned;
      trainingPopup.levelUp = false;
      trainingPopup.pendingLevelUpDialogueAt = null;
      trainingPopup.active = true;
      trainingPopup.startedAt = performance.now();

      if (playerStats.disciplineXP >= playerStats.disciplineXPNeeded) {
        trainingPopup.levelUp = true;
        trainingPopup.pendingLevelUpDialogueAt = trainingPopup.startedAt + trainingPopup.animDurationMs;
        playerStats.disciplineLevel += 1;
        if (!gameFlags.completedTraining && playerStats.disciplineLevel >= 2) {
          gameFlags.completedTraining = true;
        }
        playerStats.disciplineXP = 0;
        playerStats.disciplineXPNeeded += 5;
      }
    }

    function toggleInventory() {
      if (gameState === "inventory") {
        gameState = previousWorldState;
        interactPressed = false;
        return;
      }

      const isFreeExploreState = gameState === "overworld" || gameState === "interior";
      if (!isFreeExploreState) return;
      if (isDialogueActive() || choiceState.active || doorSequence.active) return;

      previousWorldState = gameState;
      gameState = "inventory";
      interactPressed = false;
    }


    addEventListener("keydown", (e) => {
      const key = e.key.toLowerCase();
      keys[key] = true;

      if (key === "i" && !e.repeat) {
        toggleInventory();
        return;
      }

      if (choiceState.active) {
        if (!e.repeat && (e.key === "ArrowUp" || e.key === "ArrowDown")) {
          const direction = e.key === "ArrowUp" ? -1 : 1;
          const total = choiceState.options.length;
          choiceState.selected = (choiceState.selected + direction + total) % total;
        }

        if (e.key === "Enter" && !e.repeat) {
          confirmChoice();
        }

        return;
      }

      if (e.key === "Enter" && !e.repeat) interactPressed = true;
    });

    addEventListener("keyup", (e) => {
      keys[e.key.toLowerCase()] = false;
    });

    let currentMap = overworldMap;
    let currentMapW = OVERWORLD_W;
    let currentMapH = OVERWORLD_H;
let worldName = "overworld";
    let gameState = "overworld";

    const player = {
      x: 15 * TILE,
      y: 18 * TILE,
      speed: 2.2,
      dir: "down",
      walking: false,
      frame: 0
    };

    let dialogueName = "";
    let dialogueLines = [];
    let dialogueIndex = 0;
    let dialogueEndAction = null;
    let visibleCharacters = 0;
    let textStartTime = 0;
    const charactersPerSecond = 100;

    function resetDialogueAnimation() {
      visibleCharacters = 0;
      textStartTime = performance.now();
    }

    function currentDialogueVisibleLength() {
      return currentDialogueLine().replace(/\n/g, "").length;
    }

    function updateVisibleCharacters() {
      const elapsedSeconds = Math.max(0, (performance.now() - textStartTime) / 1000);
      visibleCharacters = Math.min(currentDialogueVisibleLength(), Math.floor(elapsedSeconds * charactersPerSecond));
      return visibleCharacters;
    }

    const choiceState = {
      active: false,
      options: ["Yes", "No"],
      selected: 0,
      onConfirm: null
    };

    const doorSequence = {
      active: false,
      tx: 0,
      ty: 0,
      stepDx: 0,
      stepDy: 0,
      stepFrames: 0,
      frame: 0,
      targetWorld: "overworld",
      targetX: 0,
      targetY: 0,
      transitionPhase: "out",
      fadeRadius: 0,
      maxFadeRadius: 0
    };

    function showDialogue(name, textOrLines, endAction = null) {
      dialogueName = (name || "").trim();
      const sourceLines = Array.isArray(textOrLines) ? textOrLines : [textOrLines];

      ctx.save();
      ctx.font = "20px monospace";

      const textMaxWidth = canvas.width - 80;
      const lineSpacing = 24;
      const boxHeight = 112;
      const boxY = canvas.height - boxHeight - 20;
      const dialogueTextStartY = dialogueName ? boxY + 66 : boxY + 52;
      const maxBaselineY = boxY + boxHeight - 8;
      const maxLinesPerPage = Math.max(
        1,
        Math.floor((maxBaselineY - dialogueTextStartY) / lineSpacing) + 1
      );

      const pagedDialogue = [];

      for (const entry of sourceLines) {
        const wrapped = wrapText(ctx, String(entry ?? ""), textMaxWidth);

        for (let i = 0; i < wrapped.length; i += maxLinesPerPage) {
          const pageLines = wrapped.slice(i, i + maxLinesPerPage);
          pagedDialogue.push(pageLines.join("\n"));
        }
      }

      dialogueLines = pagedDialogue;
      ctx.restore();
      dialogueIndex = 0;
      dialogueEndAction = endAction;
      closeChoice();
      resetDialogueAnimation();
    }

    function openYesNoChoice(onConfirm) {
      choiceState.active = true;
      choiceState.selected = 0;
      choiceState.onConfirm = onConfirm;
    }

    function closeChoice() {
      choiceState.active = false;
      choiceState.selected = 0;
      choiceState.onConfirm = null;
    }

    function confirmChoice() {
      if (!choiceState.active) return;

      const selectedOption = choiceState.options[choiceState.selected];
      const onConfirm = choiceState.onConfirm;
      closeChoice();

      if (onConfirm) onConfirm(selectedOption);
    }

    function advanceDialogue() {
      if (!isDialogueActive() || choiceState.active) return;
      updateVisibleCharacters();

      if (visibleCharacters < currentDialogueVisibleLength()) {
        visibleCharacters = currentDialogueVisibleLength();
        return;
      }

      if (dialogueIndex < dialogueLines.length - 1) {
        dialogueIndex++;
        resetDialogueAnimation();
      } else if (dialogueEndAction) {
        const endAction = dialogueEndAction;
        dialogueEndAction = null;
        endAction();
      } else {
        closeDialogue();
      }
    }

    function closeDialogue() {
      dialogueName = "";
      dialogueLines = [];
      dialogueIndex = 0;
      dialogueEndAction = null;
      visibleCharacters = 0;
      textStartTime = 0;
      closeChoice();
    }

    function isDialogueActive() {
      return dialogueLines.length > 0;
    }

    function currentDialogueLine() {
      if (!isDialogueActive()) return "";
      return dialogueLines[dialogueIndex] || "";
    }

    function setWorld(name) {
      if (name === "overworld") {
        currentMap = overworldMap;
        currentMapW = OVERWORLD_W;
        currentMapH = OVERWORLD_H;
      } else {
        currentMap = interiorMap;
        currentMapW = INTERIOR_W;
        currentMapH = INTERIOR_H;
      }
      worldName = name;
    }

    function tileAtPixel(px, py) {
      const tx = Math.floor(px / TILE);
      const ty = Math.floor(py / TILE);
      if (tx < 0 || ty < 0 || tx >= currentMapW || ty >= currentMapH) return 2;
      return currentMap[ty][tx];
    }

    function isBlockedAtPixel(px, py) {
      const tile = tileAtPixel(px, py);
      return tile === 2 || tile === 3 || tile === 4 || tile === 5;
    }

    function collides(nx, ny) {
      const inset = 5;
      const left = nx + inset;
      const right = nx + TILE - inset;
      const top = ny + inset;
      const bottom = ny + TILE - inset;

      return (
        isBlockedAtPixel(left, top) ||
        isBlockedAtPixel(right, top) ||
        isBlockedAtPixel(left, bottom) ||
        isBlockedAtPixel(right, bottom)
      );
    }

    function rectsOverlap(a, b) {
      return (
        a.x < b.x + b.width &&
        a.x + a.width > b.x &&
        a.y < b.y + b.height &&
        a.y + a.height > b.y
      );
    }

    function collidesWithNPC(nx, ny) {
      const playerRect = {
        x: nx + 5,
        y: ny + 5,
        width: TILE - 10,
        height: TILE - 10
      };

      for (const npc of npcs) {
        if (npc.world !== worldName) continue;
        if (rectsOverlap(playerRect, npc)) return true;
      }

      return false;
    }

    function doorFromCollision(nx, ny) {
      const inset = 5;
      const corners = [
        [nx + inset, ny + inset],
        [nx + TILE - inset, ny + inset],
        [nx + inset, ny + TILE - inset],
        [nx + TILE - inset, ny + TILE - inset]
      ];

      for (const [px, py] of corners) {
        const tx = Math.floor(px / TILE);
        const ty = Math.floor(py / TILE);
        if (tx < 0 || ty < 0 || tx >= currentMapW || ty >= currentMapH) continue;
        if (currentMap[ty][tx] === 5) {
          return { tx, ty };
        }
      }
      return null;
    }

    function beginDoorSequence(doorTile) {
      if (gameState === "enteringDoor" || gameState === "transition") return;

      const playerCenterX = player.x + TILE / 2;
      const playerCenterY = player.y + TILE / 2;
      const doorCenterX = doorTile.tx * TILE + TILE / 2;
      const doorCenterY = doorTile.ty * TILE + TILE / 2;
      let vx = doorCenterX - playerCenterX;
      let vy = doorCenterY - playerCenterY;
      const len = Math.hypot(vx, vy) || 1;
      vx /= len;
      vy /= len;

      doorSequence.active = true;
      doorSequence.tx = doorTile.tx;
      doorSequence.ty = doorTile.ty;
      doorSequence.stepDx = vx * 1.5;
      doorSequence.stepDy = vy * 1.5;
      doorSequence.stepFrames = 20;
      doorSequence.frame = 0;

      if (worldName === "overworld") {
        doorSequence.targetWorld = "interior";
        doorSequence.targetX = interiorDoor.x * TILE;
        doorSequence.targetY = (interiorDoor.y - 1) * TILE;
      } else {
        doorSequence.targetWorld = "overworld";
        doorSequence.targetX = overworldDoor.x * TILE;
        doorSequence.targetY = (overworldDoor.y + 1) * TILE;
      }

      doorSequence.maxFadeRadius = Math.hypot(canvas.width, canvas.height);
     doorSequence.fadeRadius = doorSequence.maxFadeRadius;
      doorSequence.transitionPhase = "out";
      gameState = "enteringDoor";
      interactPressed = false;
    }

    function handleInteraction() {
      if (gameState === "inventory") {
        interactPressed = false;
        return;
      }

      if (!interactPressed) return;

      if (isDialogueActive()) {
        advanceDialogue();
        interactPressed = false;
        return;
      }

      if (gameState === "enteringDoor" || gameState === "transition") {
        interactPressed = false;
        return;
      }

      const interactReach = TILE;
      const playerCenterX = player.x + TILE / 2;
      const playerCenterY = player.y + TILE / 2;

      for (const npc of npcs) {
        if (npc.world !== worldName) continue;

        const npcCenterX = npc.x + npc.width / 2;
        const npcCenterY = npc.y + npc.height / 2;
        const dx = Math.abs(playerCenterX - npcCenterX);
        const dy = Math.abs(playerCenterY - npcCenterY);

        if (dx <= interactReach && dy <= interactReach) {
          if (npc.hasTrainingChoice) {
            if (gameFlags.completedTraining) {
              showDialogue(npc.name, ["Excellent.", "You have mastered the basics and are now ready for your next lesson. I won't tell you what it is though!"]);
              interactPressed = false;
              return;
            }

            if (gameFlags.acceptedTraining) {
              showDialogue(npc.name, npc.alreadyTrainingDialogue);
              interactPressed = false;
              return;
            }

            showDialogue(npc.name, npc.dialogue, () => {
              openYesNoChoice((selectedOption) => {
                if (selectedOption === "Yes") {
                  gameFlags.acceptedTraining = true;

                  if (!playerInventory["Training Headband"]) {
                    playerInventory["Training Headband"] = 1;
                  }

                  showDialogue(npc.name, "You received a Training Headband!");
                } else {
                  showDialogue(npc.name, "Come speak to me when you are ready.");
                }
              });
            });
          } else {
            showDialogue(npc.name, npc.dialogue);
          }

          interactPressed = false;
          return;
        }
      }

      const inset = 5;
      const left = Math.floor((player.x + inset) / TILE) - 1;
      const right = Math.floor((player.x + TILE - inset) / TILE) + 1;
      const top = Math.floor((player.y + inset) / TILE) - 1;
      const bottom = Math.floor((player.y + TILE - inset) / TILE) + 1;

      for (let ty = top; ty <= bottom; ty++) {
        if (ty < 0 || ty >= currentMapH) continue;

        for (let tx = left; tx <= right; tx++) {
          if (tx < 0 || tx >= currentMapW) continue;

          if (currentMap[ty][tx] === 4) {
            showDialogue("", "The Dojo");
            interactPressed = false;
            return;
          }
        }
      }

      if (worldName === "interior" && gameFlags.acceptedTraining) {
        const tilePos = playerTilePosition();
        const onTrainingTile = tilePos.x === trainingTile.x && tilePos.y === trainingTile.y;
        if (onTrainingTile) {
          tryTrainingAction();
          interactPressed = false;
          return;
        }
      }

      interactPressed = false;
    }

    function updatePlayerMovement() {
      let dx = 0;
      let dy = 0;

      if (keys["w"] || keys["arrowup"]) {
        dy -= player.speed;
        player.dir = "up";
      }
      if (keys["s"] || keys["arrowdown"]) {
        dy += player.speed;
        player.dir = "down";
      }
      if (keys["a"] || keys["arrowleft"]) {
        dx -= player.speed;
        player.dir = "left";
      }
      if (keys["d"] || keys["arrowright"]) {
        dx += player.speed;
        player.dir = "right";
      }

      player.walking = dx !== 0 || dy !== 0;

      if (dx !== 0 && dy !== 0) {
        const s = Math.SQRT1_2;
        dx *= s;
        dy *= s;
      }

      const nx = player.x + dx;
      const ny = player.y + dy;

      if (!collides(nx, player.y) && !collidesWithNPC(nx, player.y)) {
        player.x = nx;
      } else if (dx !== 0) {
        const doorTile = doorFromCollision(nx, player.y);
        if (doorTile) {
          beginDoorSequence(doorTile);
          return;
        }
      }

      if (!collides(player.x, ny) && !collidesWithNPC(player.x, ny)) {
        player.y = ny;
      } else if (dy !== 0) {
        const doorTile = doorFromCollision(player.x, ny);
        if (doorTile) {
          beginDoorSequence(doorTile);
          return;
        }
      }

      if (player.walking) {
        player.frame = (player.frame + 1) % 24;
      }
    }

    function updateDoorEntry() {
      player.walking = true;
      player.frame = (player.frame + 1) % 24;

      if (doorSequence.frame < doorSequence.stepFrames) {
        player.x += doorSequence.stepDx;
        player.y += doorSequence.stepDy;
        doorSequence.frame++;
      } else {
        gameState = "transition";
      }
    }

    function updateTransition() {
      player.walking = false;

     if (doorSequence.transitionPhase === "out") {
        doorSequence.fadeRadius -= 20;
        if (doorSequence.fadeRadius <= 0) {
          doorSequence.fadeRadius = 0;
          setWorld(doorSequence.targetWorld);
          player.x = doorSequence.targetX;
          player.y = doorSequence.targetY;
          player.dir = doorSequence.targetWorld === "interior" ? "up" : "down";
          doorSequence.transitionPhase = "in";
        }
      } else {
        doorSequence.fadeRadius += 20;
        if (doorSequence.fadeRadius >= doorSequence.maxFadeRadius) {
          doorSequence.fadeRadius = doorSequence.maxFadeRadius;
          doorSequence.active = false;
          gameState = worldName;
        }
      }
    }

    function update() {
      const now = performance.now();
      if (
        trainingPopup.pendingLevelUpDialogueAt !== null &&
        now >= trainingPopup.pendingLevelUpDialogueAt &&
        !isDialogueActive() &&
        !choiceState.active
      ) {
        trainingPopup.pendingLevelUpDialogueAt = null;
        showDialogue("", "Your discipline has grown! Level increased!");
      }

      if (trainingPopup.active) {
        const elapsed = now - trainingPopup.startedAt;
        if (elapsed >= trainingPopup.durationMs) {
          trainingPopup.active = false;
          trainingPopup.levelUp = false;
        }
      }

      if ((gameState === "overworld" || gameState === "interior") && !isDialogueActive()) {
        updatePlayerMovement();
      } else if (isDialogueActive()) {
        player.walking = false;
      } else if (gameState === "enteringDoor") {
        updateDoorEntry();
      } else if (gameState === "transition") {
        updateTransition();
      }

      if (gameState !== "transition") {
        handleInteraction();
      }
    }

    function camera() {
      const worldW = currentMapW * TILE;
      const worldH = currentMapH * TILE;

      let cx = player.x - canvas.width / 2 + TILE / 2;
      let cy = player.y - canvas.height / 2 + TILE / 2;

      cx = Math.max(0, Math.min(cx, Math.max(0, worldW - canvas.width)));
      cy = Math.max(0, Math.min(cy, Math.max(0, worldH - canvas.height)));

      return { x: cx, y: cy };
    }

    function drawTile(type, x, y, tileX, tileY) {
      if (type === 0) {
        ctx.fillStyle = "#7ecf7e";
        ctx.fillRect(x, y, TILE, TILE);
      }

      if (type === 1) {
        ctx.fillStyle = "#d8c89a";
        ctx.fillRect(x, y, TILE, TILE);
      }

      if (type === 2) {
        ctx.fillStyle = "#2e7d32";
        ctx.fillRect(x, y, TILE, TILE);
        ctx.fillStyle = "#1b5e20";
        ctx.fillRect(x + 8, y + 8, 16, 16);
      }

      if (type === 3) {
        ctx.fillStyle = "#8d6e63";
        ctx.fillRect(x, y, TILE, TILE);
      }

      if (type === 4) {
        ctx.fillStyle = "#6d4c41";
        ctx.fillRect(x + 12, y + 8, 8, 18);
        ctx.fillStyle = "#d7ccc8";
        ctx.fillRect(x + 6, y + 6, 20, 10);
      }

      if (type === 5) {
        const isActiveDoor =
          gameState === "enteringDoor" &&
          tileX === doorSequence.tx &&
          tileY === doorSequence.ty;

        ctx.fillStyle = isActiveDoor ? "#ffcc80" : "#5d4037";
        ctx.fillRect(x, y, TILE, TILE);

        ctx.fillStyle = isActiveDoor ? "#ffe0b2" : "#8d6e63";
        ctx.fillRect(x + 6, y + 4, 20, 24);

        ctx.fillStyle = "#3e2723";
        ctx.fillRect(x + 18, y + 14, 3, 3);
      }

      if (type === 6) {
        ctx.fillStyle = "#bca58a";
        ctx.fillRect(x, y, TILE, TILE);
        ctx.fillStyle = "#a1887f";
        ctx.fillRect(x + 2, y + 2, TILE - 4, TILE - 4);
      }

      if (type === 7) {
        ctx.fillStyle = "#8d7964";
        ctx.fillRect(x, y, TILE, TILE);
ctx.fillStyle = "#6d5b4c";
        ctx.fillRect(x + 2, y + 2, TILE - 4, TILE - 4);
      }
    }

    function drawPlayer(cam) {
      const px = player.x - cam.x;
      const py = player.y - cam.y;

      ctx.fillStyle = "#2b2b2b";
      ctx.fillRect(px + 6, py + 8, 20, 20);

      ctx.fillStyle = "#ffffff";
      ctx.fillRect(px + 10, py + 4, 12, 8);

      const legFrame = Math.floor(player.frame / 12) % 2;
      if (player.walking && legFrame === 0) {
        ctx.fillRect(px + 8, py + 26, 6, 6);
        ctx.fillRect(px + 18, py + 26, 6, 6);
      } else {
        ctx.fillRect(px + 10, py + 26, 6, 6);
        ctx.fillRect(px + 16, py + 26, 6, 6);
      }
    }

    function drawNPCs(cam) {
      if (worldName !== "interior") return;

      for (const npc of npcs) {
        if (npc.world !== worldName) continue;

        const nx = npc.x - cam.x;
        const ny = npc.y - cam.y;

        if (
          nx > -npc.width &&
          ny > -npc.height &&
          nx < canvas.width &&
          ny < canvas.height
        ) {
ctx.fillStyle = "#7b1fa2";
          ctx.fillRect(nx + 6, ny + 8, 20, 20);

          ctx.fillStyle = "#ffe0b2";
          ctx.fillRect(nx + 10, ny + 4, 12, 8);

          ctx.fillStyle = "#4a148c";
          ctx.fillRect(nx + 10, ny + 26, 6, 6);
          ctx.fillRect(nx + 16, ny + 26, 6, 6);
    }
      }
    }

    function drawTrainingPopup(cam) {
      if (!trainingPopup.active) return;

      const elapsed = performance.now() - trainingPopup.startedAt;
      const fadeRatio = Math.max(0, 1 - elapsed / trainingPopup.durationMs);
      if (fadeRatio <= 0) return;

const px = player.x - cam.x + TILE / 2;
      const py = player.y - cam.y;

      const boxW = 120;
      const boxH = 44;
      let boxX = Math.round(px - boxW / 2);
      let boxY = Math.round(py - 58);

      if (boxY < 0) {
        boxY = Math.round(py + TILE + 10);
      }

      boxX = Math.max(0, Math.min(boxX, canvas.width - boxW));
      boxY = Math.max(0, boxY);
      let progressRatio;
      if (trainingPopup.levelUp) {
        const fillProgress = Math.min(1, elapsed / trainingPopup.animDurationMs);
        const holdEnd = trainingPopup.animDurationMs + trainingPopup.levelUpHoldMs;
        if (elapsed < trainingPopup.animDurationMs) {
          progressRatio = fillProgress;
        } else if (elapsed < holdEnd) {
          progressRatio = 1;
        } else {
          progressRatio = 0;
        }
      } else {
        const animationProgress = Math.min(1, elapsed / trainingPopup.animDurationMs);
        const displayXP = trainingPopup.startXP + (trainingPopup.targetXP - trainingPopup.startXP) * animationProgress;
        progressRatio = Math.min(1, displayXP / trainingPopup.xpNeededSnapshot);
      }

      ctx.save();
      ctx.globalAlpha = fadeRatio;

      ctx.fillStyle = "rgba(12,18,28,0.9)";
      ctx.fillRect(boxX, boxY, boxW, boxH);

      ctx.strokeStyle = "#ffffff";
      ctx.lineWidth = 1;
      ctx.strokeRect(boxX, boxY, boxW, boxH);

      ctx.fillStyle = "#ffffff";
      ctx.font = "12px monospace";
      ctx.fillText(`Lv. ${playerStats.disciplineLevel}`, boxX + 8, boxY + 13);
      ctx.fillText(`+${trainingPopup.xpGained} XP`, boxX + 78, boxY + 13);

      const barX = boxX + 8;
      const barY = boxY + 21;
      const barW = boxW - 16;
      const barH = 14;

      ctx.fillStyle = "#263238";
      ctx.fillRect(barX, barY, barW, barH);

      ctx.fillStyle = "#4caf50";
      ctx.fillRect(barX, barY, Math.round(barW * progressRatio), barH);

      ctx.restore();
    }

    function wrapText(ctx, text, maxWidth) {
      const words = (text || "").split(/\s+/).filter(Boolean);
      if (words.length === 0) return [""];

      const lines = [];
      let currentLine = words[0];

      for (let i = 1; i < words.length; i++) {
        const word = words[i];
        const testLine = `${currentLine} ${word}`;

        if (ctx.measureText(testLine).width <= maxWidth) {
          currentLine = testLine;
        } else {
          lines.push(currentLine);
          currentLine = word;
        }
      }

      lines.push(currentLine);
      return lines;
    }

    function drawTextbox() {
      if (!isDialogueActive() || gameState === "inventory") return;

      const boxHeight = choiceState.active ? 152 : 112;
      const boxY = canvas.height - boxHeight - 20;

      ctx.fillStyle = "rgba(0,0,0,0.75)";
      ctx.fillRect(20, boxY, canvas.width - 40, boxHeight);

      ctx.strokeStyle = "#ffffff";
      ctx.lineWidth = 3;
      ctx.strokeRect(20, boxY, canvas.width - 40, boxHeight);

      ctx.fillStyle = "#ffffff";
      ctx.font = "20px monospace";

      const textStartX = 40;
      const lineSpacing = 24;
      const dialogueTextStartY = dialogueName ? boxY + 66 : boxY + 52;
      updateVisibleCharacters();
      const fullPageLines = currentDialogueLine().split("\n");
      const wrappedLines = [];
      let remainingCharacters = visibleCharacters;

      for (const line of fullPageLines) {
        if (remainingCharacters <= 0) break;

        const visibleInLine = Math.min(line.length, remainingCharacters);
        wrappedLines.push(line.slice(0, visibleInLine));
        remainingCharacters -= visibleInLine;

        if (visibleInLine < line.length) break;
      }

      if (dialogueName) {
        ctx.fillText(dialogueName, 40, boxY + 28);
      }

      for (let i = 0; i < wrappedLines.length; i++) {
        ctx.fillText(wrappedLines[i], textStartX, dialogueTextStartY + i * lineSpacing);
      }

      if (choiceState.active) {
        const optionsStartY = boxY + 90;
        for (let i = 0; i < choiceState.options.length; i++) {
          const prefix = i === choiceState.selected ? "â–º " : "  ";
          ctx.fillText(prefix + choiceState.options[i], 40, optionsStartY + i * 24);
        }
      }
    }

    function drawDoorTransition(cam) {
      if (gameState !== "transition") return;

      const px = player.x - cam.x + TILE / 2;
      const py = player.y - cam.y + TILE / 2;

      ctx.save();
      ctx.fillStyle = "black";
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      ctx.globalCompositeOperation = "destination-out";
      ctx.beginPath();
      ctx.arc(px, py, doorSequence.fadeRadius, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();
    }

    function drawInventoryOverlay() {
      if (gameState !== "inventory") return;

      ctx.fillStyle = "rgba(0,0,0,0.6)";
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      const boxW = 420;
      const boxH = 280;
      const boxX = (canvas.width - boxW) / 2;
      const boxY = (canvas.height - boxH) / 2;

      ctx.fillStyle = "rgba(22,28,38,0.96)";
      ctx.fillRect(boxX, boxY, boxW, boxH);

      ctx.strokeStyle = "#ffffff";
      ctx.lineWidth = 3;
      ctx.strokeRect(boxX, boxY, boxW, boxH);

      ctx.fillStyle = "#ffffff";
      ctx.font = "28px monospace";
      ctx.fillText("Inventory", boxX + 24, boxY + 42);

      const entries = Object.entries(playerInventory);
      ctx.font = "20px monospace";

      let row = 0;
      if (entries.length === 0) {
        ctx.fillText("(No items)", boxX + 24, boxY + 90);
        row = 1;
      } else {
        for (const [itemName, quantity] of entries) {
          ctx.fillText(`${itemName} x${quantity}`, boxX + 24, boxY + 90 + row * 28);
          row++;
        }
      }

      const statsY = boxY + 90 + row * 28 + 18;
      ctx.font = "22px monospace";
      ctx.fillText("Stats", boxX + 24, statsY);

      ctx.font = "20px monospace";
      const levelY = statsY + 30;
      ctx.fillText(`Discipline Lv. ${playerStats.disciplineLevel}`, boxX + 24, levelY);

      const barX = boxX + 24;
      const barY = levelY + 18;
      const barW = boxW - 48;
      const barH = 20;
      const progressRatio = Math.min(1, playerStats.disciplineXP / playerStats.disciplineXPNeeded);

      ctx.fillStyle = "#263238";
      ctx.fillRect(barX, barY, barW, barH);

      ctx.fillStyle = "#66bb6a";
      ctx.fillRect(barX, barY, barW * progressRatio, barH);

      ctx.strokeStyle = "#ffffff";
      ctx.lineWidth = 2;
      ctx.strokeRect(barX, barY, barW, barH);

      ctx.fillStyle = "#ffffff";
      ctx.font = "16px monospace";
      const progressText = `${playerStats.disciplineXP} / ${playerStats.disciplineXPNeeded}`;
      const textWidth = ctx.measureText(progressText).width;
      ctx.fillText(progressText, barX + (barW - textWidth) / 2, barY + 15);
    }

    function render() {
      const cam = camera();
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      for (let y = 0; y < currentMapH; y++) {
        for (let x = 0; x < currentMapW; x++) {
          const drawX = x * TILE - cam.x;
          const drawY = y * TILE - cam.y;

          if (
            drawX > -TILE &&
            drawY > -TILE &&
            drawX < canvas.width &&
            drawY < canvas.height
          ) {
            drawTile(currentMap[y][x], drawX, drawY, x, y);
          }
        }
      }

      drawNPCs(cam);
      drawPlayer(cam);
      drawTrainingPopup(cam);
      drawDoorTransition(cam);
      drawInventoryOverlay();
      drawTextbox();
    }

    function loop() {
      update();
      render();
      requestAnimationFrame(loop);
    }

    loop();
  </script>
</body>
</html>


