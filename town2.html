<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Dojo Town</title>
  <style>
    body {
      margin: 0;
      background: #0f1720;
      overflow: hidden;
    }

    canvas {
      display: block;
      margin: auto;
      image-rendering: pixelated;
      background: #a7d9a8;
    }
  </style>
</head>
<body>
  <canvas id="game" width="640" height="480"></canvas>

  <script>
    const canvas = document.getElementById("game");
    const ctx = canvas.getContext("2d");

    const TILE = 32;

    // 0 grass, 1 path, 2 tree, 3 dojo/wall, 4 signpost, 5 door, 6 interior floor
    const OVERWORLD_W = 30;
    const OVERWORLD_H = 30;

    const overworldMap = Array.from({ length: OVERWORLD_H }, (_, y) =>
      Array.from({ length: OVERWORLD_W }, (_, x) => {
        if (x === 0 || y === 0 || x === OVERWORLD_W - 1 || y === OVERWORLD_H - 1) return 2;
        return 0;
      })
    );

    const pathX = 15;
    for (let y = 2; y < OVERWORLD_H - 2; y++) {
      overworldMap[y][pathX] = 1;
    }

    for (let x = 8; x <= 22; x++) {
      overworldMap[15][x] = 1;
    }

    const dojoTop = 10;
    const dojoLeft = 13;
    const dojoW = 5;
    const dojoH = 4;

    for (let y = dojoTop; y < dojoTop + dojoH; y++) {
      for (let x = dojoLeft; x < dojoLeft + dojoW; x++) {
        overworldMap[y][x] = 3;
      }
    }

    const overworldDoor = { x: dojoLeft + Math.floor(dojoW / 2), y: dojoTop + dojoH - 1 };
    overworldMap[overworldDoor.y][overworldDoor.x] = 5;

    overworldMap[14][14] = 4;

    const treeClusters = [
      [4, 4], [5, 4], [4, 5], [24, 4], [25, 4], [24, 5],
      [5, 23], [4, 24], [24, 23], [25, 24], [22, 20], [8, 20]
    ];
    for (const [x, y] of treeClusters) {
      overworldMap[y][x] = 2;
    }

    const INTERIOR_W = 12;
    const INTERIOR_H = 10;
    const interiorMap = Array.from({ length: INTERIOR_H }, (_, y) =>
      Array.from({ length: INTERIOR_W }, (_, x) => {
        if (x === 0 || y === 0 || x === INTERIOR_W - 1 || y === INTERIOR_H - 1) return 3;
        return 6;
      })
    );

    const interiorDoor = { x: Math.floor(INTERIOR_W / 2), y: INTERIOR_H - 1 };
    interiorMap[interiorDoor.y][interiorDoor.x] = 5;

    // NPC entities are separate from map tiles.
    const npcs = [
      {
        world: "interior",
        x: 7 * TILE,
        y: 4 * TILE,
        width: TILE,
        height: TILE,
        name: "Mr. Hanami",
        dialogue: "Hello there! My name is Mr. Hanami. Welcome to the dojo."
      }
    ];

    const keys = {};
    let interactPressed = false;

    addEventListener("keydown", (e) => {
      keys[e.key.toLowerCase()] = true;
      if (e.key === "Enter") interactPressed = true;
    });

    addEventListener("keyup", (e) => {
      keys[e.key.toLowerCase()] = false;
    });

    let currentMap = overworldMap;
    let currentMapW = OVERWORLD_W;
    let currentMapH = OVERWORLD_H;
    let worldName = "overworld";
    let gameState = "overworld";

    const player = {
      x: 15 * TILE,
      y: 18 * TILE,
      speed: 2.2,
      dir: "down",
      walking: false,
      frame: 0
    };

    let dialogueName = "";
    let message = "";
    let messageTimer = 0;

    const doorSequence = {
      active: false,
      tx: 0,
      ty: 0,
      stepDx: 0,
      stepDy: 0,
      stepFrames: 0,
      frame: 0,
      targetWorld: "overworld",
      targetX: 0,
      targetY: 0,
      transitionPhase: "out",
      fadeRadius: 0,
      maxFadeRadius: 0
    };

    function showDialogue(name, text) {
      dialogueName = (name || "").trim();
      message = text;
      messageTimer = 180;
    }

    function setWorld(name) {
      if (name === "overworld") {
        currentMap = overworldMap;
        currentMapW = OVERWORLD_W;
        currentMapH = OVERWORLD_H;
      } else {
        currentMap = interiorMap;
        currentMapW = INTERIOR_W;
        currentMapH = INTERIOR_H;
      }
      worldName = name;
    }

    function tileAtPixel(px, py) {
      const tx = Math.floor(px / TILE);
      const ty = Math.floor(py / TILE);
      if (tx < 0 || ty < 0 || tx >= currentMapW || ty >= currentMapH) return 2;
      return currentMap[ty][tx];
    }

    function isBlockedAtPixel(px, py) {
      const tile = tileAtPixel(px, py);
      return tile === 2 || tile === 3 || tile === 4 || tile === 5;
    }

    function collides(nx, ny) {
      const inset = 5;
      const left = nx + inset;
      const right = nx + TILE - inset;
      const top = ny + inset;
      const bottom = ny + TILE - inset;

      return (
        isBlockedAtPixel(left, top) ||
        isBlockedAtPixel(right, top) ||
        isBlockedAtPixel(left, bottom) ||
        isBlockedAtPixel(right, bottom)
      );
    }

    function rectsOverlap(a, b) {
      return (
        a.x < b.x + b.width &&
        a.x + a.width > b.x &&
        a.y < b.y + b.height &&
        a.y + a.height > b.y
      );
    }

    function collidesWithNPC(nx, ny) {
      const playerRect = {
        x: nx + 5,
        y: ny + 5,
        width: TILE - 10,
        height: TILE - 10
      };

      for (const npc of npcs) {
        if (npc.world !== worldName) continue;
        if (rectsOverlap(playerRect, npc)) return true;
      }

      return false;
    }

    function doorFromCollision(nx, ny) {
      const inset = 5;
      const corners = [
        [nx + inset, ny + inset],
        [nx + TILE - inset, ny + inset],
        [nx + inset, ny + TILE - inset],
        [nx + TILE - inset, ny + TILE - inset]
      ];

      for (const [px, py] of corners) {
        const tx = Math.floor(px / TILE);
        const ty = Math.floor(py / TILE);
        if (tx < 0 || ty < 0 || tx >= currentMapW || ty >= currentMapH) continue;
        if (currentMap[ty][tx] === 5) {
          return { tx, ty };
        }
      }
      return null;
    }

    function beginDoorSequence(doorTile) {
      if (gameState === "enteringDoor" || gameState === "transition") return;

      const playerCenterX = player.x + TILE / 2;
      const playerCenterY = player.y + TILE / 2;
      const doorCenterX = doorTile.tx * TILE + TILE / 2;
      const doorCenterY = doorTile.ty * TILE + TILE / 2;
      let vx = doorCenterX - playerCenterX;
      let vy = doorCenterY - playerCenterY;
      const len = Math.hypot(vx, vy) || 1;
      vx /= len;
      vy /= len;

      doorSequence.active = true;
      doorSequence.tx = doorTile.tx;
      doorSequence.ty = doorTile.ty;
      doorSequence.stepDx = vx * 1.5;
      doorSequence.stepDy = vy * 1.5;
      doorSequence.stepFrames = 20;
      doorSequence.frame = 0;

      if (worldName === "overworld") {
        doorSequence.targetWorld = "interior";
        doorSequence.targetX = interiorDoor.x * TILE;
        doorSequence.targetY = (interiorDoor.y - 1) * TILE;
      } else {
        doorSequence.targetWorld = "overworld";
        doorSequence.targetX = overworldDoor.x * TILE;
        doorSequence.targetY = (overworldDoor.y + 1) * TILE;
      }

      doorSequence.maxFadeRadius = Math.hypot(canvas.width, canvas.height);
      doorSequence.fadeRadius = doorSequence.maxFadeRadius;
      doorSequence.transitionPhase = "out";
      gameState = "enteringDoor";
      interactPressed = false;
    }

    function handleInteraction() {
      if (!interactPressed) return;
      if (gameState === "enteringDoor" || gameState === "transition") {
        interactPressed = false;
        return;
      }

      const inset = 5;
      const left = Math.floor((player.x + inset) / TILE) - 1;
      const right = Math.floor((player.x + TILE - inset) / TILE) + 1;
      const top = Math.floor((player.y + inset) / TILE) - 1;
      const bottom = Math.floor((player.y + TILE - inset) / TILE) + 1;

      for (let ty = top; ty <= bottom; ty++) {
        if (ty < 0 || ty >= currentMapH) continue;

        for (let tx = left; tx <= right; tx++) {
          if (tx < 0 || tx >= currentMapW) continue;

          if (currentMap[ty][tx] === 4) {
            showDialogue("", "The Dojo");
            interactPressed = false;
            return;
          }
        }
      }

      const interactReach = TILE;
      const playerCenterX = player.x + TILE / 2;
      const playerCenterY = player.y + TILE / 2;

      for (const npc of npcs) {
        if (npc.world !== worldName) continue;

        const npcCenterX = npc.x + npc.width / 2;
        const npcCenterY = npc.y + npc.height / 2;
        const dx = Math.abs(playerCenterX - npcCenterX);
        const dy = Math.abs(playerCenterY - npcCenterY);

        if (dx <= interactReach && dy <= interactReach) {
          showDialogue("Mr. Hanami", "Hello there! My name is Mr. Hanami. Welcome to the dojo.");
          interactPressed = false;
          return;
        }
      }

      interactPressed = false;
    }

    function updatePlayerMovement() {
      let dx = 0;
      let dy = 0;

      if (keys["w"] || keys["arrowup"]) {
        dy -= player.speed;
        player.dir = "up";
      }
      if (keys["s"] || keys["arrowdown"]) {
        dy += player.speed;
        player.dir = "down";
      }
      if (keys["a"] || keys["arrowleft"]) {
        dx -= player.speed;
        player.dir = "left";
      }
      if (keys["d"] || keys["arrowright"]) {
        dx += player.speed;
        player.dir = "right";
      }

      player.walking = dx !== 0 || dy !== 0;

      if (dx !== 0 && dy !== 0) {
        const s = Math.SQRT1_2;
        dx *= s;
        dy *= s;
      }

      const nx = player.x + dx;
      const ny = player.y + dy;

      if (!collides(nx, player.y) && !collidesWithNPC(nx, player.y)) {
        player.x = nx;
      } else if (dx !== 0) {
        const doorTile = doorFromCollision(nx, player.y);
        if (doorTile) {
          beginDoorSequence(doorTile);
          return;
        }
      }

      if (!collides(player.x, ny) && !collidesWithNPC(player.x, ny)) {
        player.y = ny;
      } else if (dy !== 0) {
        const doorTile = doorFromCollision(player.x, ny);
        if (doorTile) {
          beginDoorSequence(doorTile);
          return;
        }
      }

      if (player.walking) {
        player.frame = (player.frame + 1) % 24;
      }
    }

    function updateDoorEntry() {
      player.walking = true;
      player.frame = (player.frame + 1) % 24;

      if (doorSequence.frame < doorSequence.stepFrames) {
        player.x += doorSequence.stepDx;
        player.y += doorSequence.stepDy;
        doorSequence.frame++;
      } else {
        gameState = "transition";
      }
    }

    function updateTransition() {
      player.walking = false;

      if (doorSequence.transitionPhase === "out") {
        doorSequence.fadeRadius -= 20;
        if (doorSequence.fadeRadius <= 0) {
          doorSequence.fadeRadius = 0;
          setWorld(doorSequence.targetWorld);
          player.x = doorSequence.targetX;
          player.y = doorSequence.targetY;
          player.dir = doorSequence.targetWorld === "interior" ? "up" : "down";
          doorSequence.transitionPhase = "in";
        }
      } else {
        doorSequence.fadeRadius += 20;
        if (doorSequence.fadeRadius >= doorSequence.maxFadeRadius) {
          doorSequence.fadeRadius = doorSequence.maxFadeRadius;
          doorSequence.active = false;
          gameState = worldName;
        }
      }
    }

    function update() {
      if (gameState === "overworld" || gameState === "interior") {
        updatePlayerMovement();
      } else if (gameState === "enteringDoor") {
        updateDoorEntry();
      } else if (gameState === "transition") {
        updateTransition();
      }

      if (gameState !== "transition") {
        handleInteraction();
      }
    }

    function camera() {
      const worldW = currentMapW * TILE;
      const worldH = currentMapH * TILE;

      let cx = player.x - canvas.width / 2 + TILE / 2;
      let cy = player.y - canvas.height / 2 + TILE / 2;

      cx = Math.max(0, Math.min(cx, Math.max(0, worldW - canvas.width)));
      cy = Math.max(0, Math.min(cy, Math.max(0, worldH - canvas.height)));

      return { x: cx, y: cy };
    }

    function drawTile(type, x, y, tileX, tileY) {
      if (type === 0) {
        ctx.fillStyle = "#7ecf7e";
        ctx.fillRect(x, y, TILE, TILE);
      }

      if (type === 1) {
        ctx.fillStyle = "#d8c89a";
        ctx.fillRect(x, y, TILE, TILE);
      }

      if (type === 2) {
        ctx.fillStyle = "#2e7d32";
        ctx.fillRect(x, y, TILE, TILE);
        ctx.fillStyle = "#1b5e20";
        ctx.fillRect(x + 8, y + 8, 16, 16);
      }

      if (type === 3) {
        ctx.fillStyle = "#8d6e63";
        ctx.fillRect(x, y, TILE, TILE);
      }

      if (type === 4) {
        ctx.fillStyle = "#6d4c41";
        ctx.fillRect(x + 12, y + 8, 8, 18);
        ctx.fillStyle = "#d7ccc8";
        ctx.fillRect(x + 6, y + 6, 20, 10);
      }

      if (type === 5) {
        const isActiveDoor =
          gameState === "enteringDoor" &&
          tileX === doorSequence.tx &&
          tileY === doorSequence.ty;

        ctx.fillStyle = isActiveDoor ? "#ffcc80" : "#5d4037";
        ctx.fillRect(x, y, TILE, TILE);

        ctx.fillStyle = isActiveDoor ? "#ffe0b2" : "#8d6e63";
        ctx.fillRect(x + 6, y + 4, 20, 24);

        ctx.fillStyle = "#3e2723";
        ctx.fillRect(x + 18, y + 14, 3, 3);
      }

      if (type === 6) {
        ctx.fillStyle = "#bca58a";
        ctx.fillRect(x, y, TILE, TILE);
        ctx.fillStyle = "#a1887f";
        ctx.fillRect(x + 2, y + 2, TILE - 4, TILE - 4);
      }
    }

    function drawPlayer(cam) {
      const px = player.x - cam.x;
      const py = player.y - cam.y;

      ctx.fillStyle = "#2b2b2b";
      ctx.fillRect(px + 6, py + 8, 20, 20);

      ctx.fillStyle = "#ffffff";
      ctx.fillRect(px + 10, py + 4, 12, 8);

      const legFrame = Math.floor(player.frame / 12) % 2;
      if (player.walking && legFrame === 0) {
        ctx.fillRect(px + 8, py + 26, 6, 6);
        ctx.fillRect(px + 18, py + 26, 6, 6);
      } else {
        ctx.fillRect(px + 10, py + 26, 6, 6);
        ctx.fillRect(px + 16, py + 26, 6, 6);
      }
    }

    function drawNPCs(cam) {
      if (worldName !== "interior") return;

      for (const npc of npcs) {
        if (npc.world !== worldName) continue;

        const nx = npc.x - cam.x;
        const ny = npc.y - cam.y;

        if (
          nx > -npc.width &&
          ny > -npc.height &&
          nx < canvas.width &&
          ny < canvas.height
        ) {
          ctx.fillStyle = "#7b1fa2";
          ctx.fillRect(nx + 6, ny + 8, 20, 20);

          ctx.fillStyle = "#ffe0b2";
          ctx.fillRect(nx + 10, ny + 4, 12, 8);

          ctx.fillStyle = "#4a148c";
          ctx.fillRect(nx + 10, ny + 26, 6, 6);
          ctx.fillRect(nx + 16, ny + 26, 6, 6);
        }
      }
    }

    function drawTextbox() {
      if (messageTimer <= 0) return;

      const boxHeight = 90;
      const boxY = canvas.height - boxHeight - 20;

      ctx.fillStyle = "rgba(0,0,0,0.75)";
      ctx.fillRect(20, boxY, canvas.width - 40, boxHeight);

      ctx.strokeStyle = "#ffffff";
      ctx.lineWidth = 3;
      ctx.strokeRect(20, boxY, canvas.width - 40, boxHeight);

      ctx.fillStyle = "#ffffff";
      if (dialogueName) {
        ctx.font = "20px monospace";
        ctx.fillText(dialogueName, 40, boxY + 28);
        ctx.fillText(message, 40, boxY + 62);
      } else {
        ctx.font = "20px monospace";
        ctx.fillText(message, 40, boxY + 48);
      }

      messageTimer--;
    }

    function drawDoorTransition(cam) {
      if (gameState !== "transition") return;

      const px = player.x - cam.x + TILE / 2;
      const py = player.y - cam.y + TILE / 2;

      ctx.save();
      ctx.fillStyle = "black";
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      ctx.globalCompositeOperation = "destination-out";
      ctx.beginPath();
      ctx.arc(px, py, doorSequence.fadeRadius, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();
    }

    function render() {
      const cam = camera();
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      for (let y = 0; y < currentMapH; y++) {
        for (let x = 0; x < currentMapW; x++) {
          const drawX = x * TILE - cam.x;
          const drawY = y * TILE - cam.y;

          if (
            drawX > -TILE &&
            drawY > -TILE &&
            drawX < canvas.width &&
            drawY < canvas.height
          ) {
            drawTile(currentMap[y][x], drawX, drawY, x, y);
          }
        }
      }

      drawNPCs(cam);
      drawPlayer(cam);
      drawDoorTransition(cam);
      drawTextbox();
    }

    function loop() {
      update();
      render();
      requestAnimationFrame(loop);
    }

    loop();
  </script>
</body>
</html>

