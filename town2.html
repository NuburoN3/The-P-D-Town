<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Dojo Town</title>
  <style>
    body {
      margin: 0;
      background: #0f1720;
      overflow: hidden;
    }

    canvas {
      display: block;
      margin: auto;
      image-rendering: pixelated;
      background: #a7d9a8;
    }
  </style>
</head>
<body>
  <canvas id="game" width="640" height="480"></canvas>

  <script>
    const canvas = document.getElementById("game");
    const ctx = canvas.getContext("2d");

    const TILE = 32;

    const gameFlags = {
      acceptedTraining: false
    };

    const playerInventory = {};

    // 0 grass, 1 path, 2 tree, 3 dojo/wall, 4 signpost, 5 door, 6 interior floor
    const OVERWORLD_W = 30;
    const OVERWORLD_H = 30;

    const overworldMap = Array.from({ length: OVERWORLD_H }, (_, y) =>
      Array.from({ length: OVERWORLD_W }, (_, x) => {
        if (x === 0 || y === 0 || x === OVERWORLD_W - 1 || y === OVERWORLD_H - 1) return 2;
        return 0;
      })
    );

    const pathX = 15;
    for (let y = 2; y < OVERWORLD_H - 2; y++) {
      overworldMap[y][pathX] = 1;
    }

    for (let x = 8; x <= 22; x++) {
      overworldMap[15][x] = 1;
    }

    const dojoTop = 10;
    const dojoLeft = 13;
    const dojoW = 5;
    const dojoH = 4;

    for (let y = dojoTop; y < dojoTop + dojoH; y++) {
      for (let x = dojoLeft; x < dojoLeft + dojoW; x++) {
        overworldMap[y][x] = 3;
      }
    }

    const overworldDoor = { x: dojoLeft + Math.floor(dojoW / 2), y: dojoTop + dojoH - 1 };
    overworldMap[overworldDoor.y][overworldDoor.x] = 5;

    overworldMap[14][14] = 4;

    const treeClusters = [
      [4, 4], [5, 4], [4, 5], [24, 4], [25, 4], [24, 5],
       [5, 23], [4, 24], [24, 23], [25, 24], [22, 20], [8, 20]
    ];
    for (const [x, y] of treeClusters) {
      overworldMap[y][x] = 2;
    }

    const INTERIOR_W = 12;
    const INTERIOR_H = 10;
   const interiorMap = Array.from({ length: INTERIOR_H }, (_, y) =>
      Array.from({ length: INTERIOR_W }, (_, x) => {
        if (x === 0 || y === 0 || x === INTERIOR_W - 1 || y === INTERIOR_H - 1) return 3;
        return 6;
      })
    );

    const interiorDoor = { x: Math.floor(INTERIOR_W / 2), y: INTERIOR_H - 1 };
    interiorMap[interiorDoor.y][interiorDoor.x] = 5;

    // NPC entities are separate from map tiles.
    const npcs = [
      {
        world: "interior",
        x: 7 * TILE,
        y: 4 * TILE,
        width: TILE,
        height: TILE,
        name: "Mr. Hanami",
        dialogue: ["Hello there!", "Welcome to the dojo.", "I train students here", "where they practice Hana Sakura style Karate", "which means \"the way of the cherry blossom\".", "Would you like me to teach you?"],
        alreadyTrainingDialogue: "Your training has already begun. Focus your mind.",
        hasTrainingChoice: true
      }
    ];

    const keys = {};
    let interactPressed = false;
    let previousWorldState = "overworld";

    function toggleInventory() {
      if (gameState === "inventory") {
        gameState = previousWorldState;
        interactPressed = false;
        return;
      }

      const isFreeExploreState = gameState === "overworld" || gameState === "interior";
      if (!isFreeExploreState) return;
      if (isDialogueActive() || choiceState.active || doorSequence.active) return;

      previousWorldState = gameState;
      gameState = "inventory";
      interactPressed = false;
    }

    addEventListener("keydown", (e) => {
      const key = e.key.toLowerCase();
      keys[key] = true;

      if (key === "i" && !e.repeat) {
        toggleInventory();
        return;
      }

      if (choiceState.active) {
        if (!e.repeat && (e.key === "ArrowUp" || e.key === "ArrowDown")) {
          const direction = e.key === "ArrowUp" ? -1 : 1;
          const total = choiceState.options.length;
          choiceState.selected = (choiceState.selected + direction + total) % total;
        }

        if (e.key === "Enter" && !e.repeat) {
          confirmChoice();
        }

        return;
      }

      if (e.key === "Enter" && !e.repeat) interactPressed = true;
    });

    addEventListener("keyup", (e) => {
      keys[e.key.toLowerCase()] = false;
    });

    let currentMap = overworldMap;
    let currentMapW = OVERWORLD_W;
    let currentMapH = OVERWORLD_H;
    let worldName = "overworld";
    let gameState = "overworld";

    const player = {
      x: 15 * TILE,
      y: 18 * TILE,
      speed: 2.2,
      dir: "down",
      walking: false,
      frame: 0
    };

    let dialogueName = "";
    let dialogueLines = [];
    let dialogueIndex = 0;
    let dialogueEndAction = null;

    const choiceState = {
      active: false,
      options: ["Yes", "No"],
      selected: 0,
      onConfirm: null
    };

    const doorSequence = {
      active: false,
      tx: 0,
      ty: 0,
      stepDx: 0,
      stepDy: 0,
      stepFrames: 0,
      frame: 0,
      targetWorld: "overworld",
      targetX: 0,
      targetY: 0,
      transitionPhase: "out",
      fadeRadius: 0,
      maxFadeRadius: 0
    };

    function showDialogue(name, textOrLines, endAction = null) {
      dialogueName = (name || "").trim();
      dialogueLines = Array.isArray(textOrLines) ? textOrLines : [textOrLines];
      dialogueIndex = 0;
      dialogueEndAction = endAction;
      closeChoice();
    }

    function openYesNoChoice(onConfirm) {
      choiceState.active = true;
      choiceState.selected = 0;
      choiceState.onConfirm = onConfirm;
    }

    function closeChoice() {
      choiceState.active = false;
      choiceState.selected = 0;
      choiceState.onConfirm = null;
    }

    function confirmChoice() {
      if (!choiceState.active) return;

      const selectedOption = choiceState.options[choiceState.selected];
      const onConfirm = choiceState.onConfirm;
      closeChoice();

      if (onConfirm) onConfirm(selectedOption);
    }

    function advanceDialogue() {
      if (!isDialogueActive() || choiceState.active) return;

      if (dialogueIndex < dialogueLines.length - 1) {
        dialogueIndex++;
      } else if (dialogueEndAction) {
        const endAction = dialogueEndAction;
        dialogueEndAction = null;
        endAction();
      } else {
        closeDialogue();
      }
    }

    function closeDialogue() {
      dialogueName = "";
      dialogueLines = [];
      dialogueIndex = 0;
      dialogueEndAction = null;
      closeChoice();
    }

    function isDialogueActive() {
      return dialogueLines.length > 0;
    }

    function currentDialogueLine() {
      if (!isDialogueActive()) return "";
      return dialogueLines[dialogueIndex] || "";
    }

    function setWorld(name) {
      if (name === "overworld") {
        currentMap = overworldMap;
        currentMapW = OVERWORLD_W;
        currentMapH = OVERWORLD_H;
      } else {
        currentMap = interiorMap;
        currentMapW = INTERIOR_W;
        currentMapH = INTERIOR_H;
      }
      worldName = name;
    }

    function tileAtPixel(px, py) {
      const tx = Math.floor(px / TILE);
      const ty = Math.floor(py / TILE);
      if (tx < 0 || ty < 0 || tx >= currentMapW || ty >= currentMapH) return 2;
      return currentMap[ty][tx];
    }

    function isBlockedAtPixel(px, py) {
      const tile = tileAtPixel(px, py);
      return tile === 2 || tile === 3 || tile === 4 || tile === 5;
    }

    function collides(nx, ny) {
      const inset = 5;
      const left = nx + inset;
      const right = nx + TILE - inset;
      const top = ny + inset;
      const bottom = ny + TILE - inset;

      return (
        isBlockedAtPixel(left, top) ||
        isBlockedAtPixel(right, top) ||
        isBlockedAtPixel(left, bottom) ||
        isBlockedAtPixel(right, bottom)
      );
    }

    function rectsOverlap(a, b) {
      return (
        a.x < b.x + b.width &&
        a.x + a.width > b.x &&
        a.y < b.y + b.height &&
        a.y + a.height > b.y
      );
    }

    function collidesWithNPC(nx, ny) {
      const playerRect = {
        x: nx + 5,
        y: ny + 5,
        width: TILE - 10,
        height: TILE - 10
      };

      for (const npc of npcs) {
        if (npc.world !== worldName) continue;
        if (rectsOverlap(playerRect, npc)) return true;
      }

      return false;
    }

    function doorFromCollision(nx, ny) {
      const inset = 5;
      const corners = [
        [nx + inset, ny + inset],
        [nx + TILE - inset, ny + inset],
        [nx + inset, ny + TILE - inset],
        [nx + TILE - inset, ny + TILE - inset]
      ];

      for (const [px, py] of corners) {
        const tx = Math.floor(px / TILE);
        const ty = Math.floor(py / TILE);
        if (tx < 0 || ty < 0 || tx >= currentMapW || ty >= currentMapH) continue;
        if (currentMap[ty][tx] === 5) {
          return { tx, ty };
        }
      }
      return null;
    }

    function beginDoorSequence(doorTile) {
      if (gameState === "enteringDoor" || gameState === "transition") return;

      const playerCenterX = player.x + TILE / 2;
      const playerCenterY = player.y + TILE / 2;
      const doorCenterX = doorTile.tx * TILE + TILE / 2;
      const doorCenterY = doorTile.ty * TILE + TILE / 2;
      let vx = doorCenterX - playerCenterX;
      let vy = doorCenterY - playerCenterY;
      const len = Math.hypot(vx, vy) || 1;
      vx /= len;
      vy /= len;

      doorSequence.active = true;
      doorSequence.tx = doorTile.tx;
      doorSequence.ty = doorTile.ty;
      doorSequence.stepDx = vx * 1.5;
      doorSequence.stepDy = vy * 1.5;
      doorSequence.stepFrames = 20;
      doorSequence.frame = 0;

      if (worldName === "overworld") {
        doorSequence.targetWorld = "interior";
        doorSequence.targetX = interiorDoor.x * TILE;
        doorSequence.targetY = (interiorDoor.y - 1) * TILE;
      } else {
        doorSequence.targetWorld = "overworld";
        doorSequence.targetX = overworldDoor.x * TILE;
        doorSequence.targetY = (overworldDoor.y + 1) * TILE;
      }

      doorSequence.maxFadeRadius = Math.hypot(canvas.width, canvas.height);
      doorSequence.fadeRadius = doorSequence.maxFadeRadius;
      doorSequence.transitionPhase = "out";
      gameState = "enteringDoor";
      interactPressed = false;
    }

    function handleInteraction() {
      if (gameState === "inventory") {
        interactPressed = false;
        return;
      }

      if (!interactPressed) return;

      if (isDialogueActive()) {
        advanceDialogue();
        interactPressed = false;
        return;
      }

      if (gameState === "enteringDoor" || gameState === "transition") {
        interactPressed = false;
        return;
      }

      const inset = 5;
      const left = Math.floor((player.x + inset) / TILE) - 1;
      const right = Math.floor((player.x + TILE - inset) / TILE) + 1;
      const top = Math.floor((player.y + inset) / TILE) - 1;
      const bottom = Math.floor((player.y + TILE - inset) / TILE) + 1;

      for (let ty = top; ty <= bottom; ty++) {
   if (ty < 0 || ty >= currentMapH) continue;

        for (let tx = left; tx <= right; tx++) {
          if (tx < 0 || tx >= currentMapW) continue;

          if (currentMap[ty][tx] === 4) {
            showDialogue("", "The Dojo");
            interactPressed = false;
            return;
          }
        }
      }

      const interactReach = TILE;
      const playerCenterX = player.x + TILE / 2;
      const playerCenterY = player.y + TILE / 2;

      for (const npc of npcs) {
        if (npc.world !== worldName) continue;

        const npcCenterX = npc.x + npc.width / 2;
        const npcCenterY = npc.y + npc.height / 2;
        const dx = Math.abs(playerCenterX - npcCenterX);
        const dy = Math.abs(playerCenterY - npcCenterY);

        if (dx <= interactReach && dy <= interactReach) {
          if (npc.hasTrainingChoice) {
            if (gameFlags.acceptedTraining) {
              showDialogue(npc.name, npc.alreadyTrainingDialogue);
              interactPressed = false;
              return;
            }

            showDialogue(npc.name, npc.dialogue, () => {
              openYesNoChoice((selectedOption) => {
                if (selectedOption === "Yes") {
                  gameFlags.acceptedTraining = true;

                  if (!playerInventory["Training Headband"]) {
                    playerInventory["Training Headband"] = 1;
                  }

                  showDialogue(npc.name, "You received a Training Headband!");
                } else {
                  showDialogue(npc.name, "Come speak to me when you are ready.");
                }
              });
            });
          } else {
            showDialogue(npc.name, npc.dialogue);
          }

          interactPressed = false;
          return;
        }
      }

      interactPressed = false;
    }

    function updatePlayerMovement() {
      let dx = 0;
      let dy = 0;

      if (keys["w"] || keys["arrowup"]) {
        dy -= player.speed;
        player.dir = "up";
      }
      if (keys["s"] || keys["arrowdown"]) {
        dy += player.speed;
        player.dir = "down";
      }
      if (keys["a"] || keys["arrowleft"]) {
        dx -= player.speed;
        player.dir = "left";
      }
      if (keys["d"] || keys["arrowright"]) {
        dx += player.speed;
        player.dir = "right";
      }

      player.walking = dx !== 0 || dy !== 0;

      if (dx !== 0 && dy !== 0) {
        const s = Math.SQRT1_2;
        dx *= s;
        dy *= s;
      }

      const nx = player.x + dx;
      const ny = player.y + dy;

      if (!collides(nx, player.y) && !collidesWithNPC(nx, player.y)) {
        player.x = nx;
      } else if (dx !== 0) {
        const doorTile = doorFromCollision(nx, player.y);
        if (doorTile) {
          beginDoorSequence(doorTile);
          return;
        }
      }

      if (!collides(player.x, ny) && !collidesWithNPC(player.x, ny)) {
        player.y = ny;
      } else if (dy !== 0) {
        const doorTile = doorFromCollision(player.x, ny);
        if (doorTile) {
          beginDoorSequence(doorTile);
          return;
        }
      }

      if (player.walking) {
        player.frame = (player.frame + 1) % 24;
      }
    }

    function updateDoorEntry() {
      player.walking = true;
      player.frame = (player.frame + 1) % 24;

      if (doorSequence.frame < doorSequence.stepFrames) {
        player.x += doorSequence.stepDx;
        player.y += doorSequence.stepDy;
        doorSequence.frame++;
      } else {
        gameState = "transition";
      }
    }

    function updateTransition() {
      player.walking = false;

      if (doorSequence.transitionPhase === "out") {
        doorSequence.fadeRadius -= 20;
        if (doorSequence.fadeRadius <= 0) {
          doorSequence.fadeRadius = 0;
          setWorld(doorSequence.targetWorld);
          player.x = doorSequence.targetX;
          player.y = doorSequence.targetY;
          player.dir = doorSequence.targetWorld === "interior" ? "up" : "down";
          doorSequence.transitionPhase = "in";
        }
      } else {
        doorSequence.fadeRadius += 20;
        if (doorSequence.fadeRadius >= doorSequence.maxFadeRadius) {
          doorSequence.fadeRadius = doorSequence.maxFadeRadius;
          doorSequence.active = false;
          gameState = worldName;
        }
      }
    }

    function update() {
      if ((gameState === "overworld" || gameState === "interior") && !isDialogueActive()) {
        updatePlayerMovement();
      } else if (isDialogueActive()) {
        player.walking = false;
      } else if (gameState === "enteringDoor") {
        updateDoorEntry();
      } else if (gameState === "transition") {
        updateTransition();
      }

      if (gameState !== "transition") {
        handleInteraction();
      }
    }

    function camera() {
      const worldW = currentMapW * TILE;
      const worldH = currentMapH * TILE;

      let cx = player.x - canvas.width / 2 + TILE / 2;
      let cy = player.y - canvas.height / 2 + TILE / 2;

      cx = Math.max(0, Math.min(cx, Math.max(0, worldW - canvas.width)));
      cy = Math.max(0, Math.min(cy, Math.max(0, worldH - canvas.height)));

      return { x: cx, y: cy };
    }

    function drawTile(type, x, y, tileX, tileY) {
      if (type === 0) {
        ctx.fillStyle = "#7ecf7e";
        ctx.fillRect(x, y, TILE, TILE);
      }

      if (type === 1) {
        ctx.fillStyle = "#d8c89a";
        ctx.fillRect(x, y, TILE, TILE);
      }

      if (type === 2) {
        ctx.fillStyle = "#2e7d32";
        ctx.fillRect(x, y, TILE, TILE);
        ctx.fillStyle = "#1b5e20";
        ctx.fillRect(x + 8, y + 8, 16, 16);
      }

      if (type === 3) {
        ctx.fillStyle = "#8d6e63";
        ctx.fillRect(x, y, TILE, TILE);
      }

      if (type === 4) {
        ctx.fillStyle = "#6d4c41";
        ctx.fillRect(x + 12, y + 8, 8, 18);
        ctx.fillStyle = "#d7ccc8";
        ctx.fillRect(x + 6, y + 6, 20, 10);
      }

      if (type === 5) {
        const isActiveDoor =
          gameState === "enteringDoor" &&
          tileX === doorSequence.tx &&
          tileY === doorSequence.ty;

        ctx.fillStyle = isActiveDoor ? "#ffcc80" : "#5d4037";
        ctx.fillRect(x, y, TILE, TILE);

        ctx.fillStyle = isActiveDoor ? "#ffe0b2" : "#8d6e63";
        ctx.fillRect(x + 6, y + 4, 20, 24);

        ctx.fillStyle = "#3e2723";
        ctx.fillRect(x + 18, y + 14, 3, 3);
      }

      if (type === 6) {
        ctx.fillStyle = "#bca58a";
        ctx.fillRect(x, y, TILE, TILE);
        ctx.fillStyle = "#a1887f";
        ctx.fillRect(x + 2, y + 2, TILE - 4, TILE - 4);
      }
    }

    function drawPlayer(cam) {
      const px = player.x - cam.x;
      const py = player.y - cam.y;

      ctx.fillStyle = "#2b2b2b";
      ctx.fillRect(px + 6, py + 8, 20, 20);

      ctx.fillStyle = "#ffffff";
      ctx.fillRect(px + 10, py + 4, 12, 8);

      const legFrame = Math.floor(player.frame / 12) % 2;
      if (player.walking && legFrame === 0) {
        ctx.fillRect(px + 8, py + 26, 6, 6);
        ctx.fillRect(px + 18, py + 26, 6, 6);
      } else {
        ctx.fillRect(px + 10, py + 26, 6, 6);
        ctx.fillRect(px + 16, py + 26, 6, 6);
      }
    }

    function drawNPCs(cam) {
      if (worldName !== "interior") return;

      for (const npc of npcs) {
        if (npc.world !== worldName) continue;

        const nx = npc.x - cam.x;
        const ny = npc.y - cam.y;

        if (
          nx > -npc.width &&
          ny > -npc.height &&
          nx < canvas.width &&
          ny < canvas.height
        ) {
          ctx.fillStyle = "#7b1fa2";
          ctx.fillRect(nx + 6, ny + 8, 20, 20);

          ctx.fillStyle = "#ffe0b2";
          ctx.fillRect(nx + 10, ny + 4, 12, 8);

          ctx.fillStyle = "#4a148c";
          ctx.fillRect(nx + 10, ny + 26, 6, 6);
          ctx.fillRect(nx + 16, ny + 26, 6, 6);
        }
      }
    }

    function drawTextbox() {
      if (!isDialogueActive() || gameState === "inventory") return;

      const boxHeight = choiceState.active ? 130 : 90;
      const boxY = canvas.height - boxHeight - 20;

      ctx.fillStyle = "rgba(0,0,0,0.75)";
      ctx.fillRect(20, boxY, canvas.width - 40, boxHeight);

      ctx.strokeStyle = "#ffffff";
      ctx.lineWidth = 3;
      ctx.strokeRect(20, boxY, canvas.width - 40, boxHeight);

      ctx.fillStyle = "#ffffff";
      ctx.font = "20px monospace";
      if (dialogueName) {
        ctx.fillText(dialogueName, 40, boxY + 28);
        ctx.fillText(currentDialogueLine(), 40, boxY + 62);
      } else {
        ctx.fillText(currentDialogueLine(), 40, boxY + 48);
      }

      if (choiceState.active) {
        const optionsStartY = boxY + 90;
        for (let i = 0; i < choiceState.options.length; i++) {
          const prefix = i === choiceState.selected ? "â–º " : "  ";
          ctx.fillText(prefix + choiceState.options[i], 40, optionsStartY + i * 24);
        }
      }
    }

    function drawDoorTransition(cam) {
      if (gameState !== "transition") return;

      const px = player.x - cam.x + TILE / 2;
      const py = player.y - cam.y + TILE / 2;

      ctx.save();
      ctx.fillStyle = "black";
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      ctx.globalCompositeOperation = "destination-out";
      ctx.beginPath();
      ctx.arc(px, py, doorSequence.fadeRadius, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();
    }

    function drawInventoryOverlay() {
      if (gameState !== "inventory") return;

      ctx.fillStyle = "rgba(0,0,0,0.6)";
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      const boxW = 420;
      const boxH = 280;
      const boxX = (canvas.width - boxW) / 2;
      const boxY = (canvas.height - boxH) / 2;

      ctx.fillStyle = "rgba(22,28,38,0.96)";
      ctx.fillRect(boxX, boxY, boxW, boxH);

      ctx.strokeStyle = "#ffffff";
      ctx.lineWidth = 3;
      ctx.strokeRect(boxX, boxY, boxW, boxH);

      ctx.fillStyle = "#ffffff";
      ctx.font = "28px monospace";
      ctx.fillText("Inventory", boxX + 24, boxY + 42);

      const entries = Object.entries(playerInventory);
      ctx.font = "20px monospace";

      if (entries.length === 0) {
        ctx.fillText("(No items)", boxX + 24, boxY + 90);
        return;
      }

      let row = 0;
      for (const [itemName, quantity] of entries) {
        ctx.fillText(`${itemName} x${quantity}`, boxX + 24, boxY + 90 + row * 28);
        row++;
      }
    }

    function render() {
      const cam = camera();
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      for (let y = 0; y < currentMapH; y++) {
        for (let x = 0; x < currentMapW; x++) {
          const drawX = x * TILE - cam.x;
          const drawY = y * TILE - cam.y;

          if (
            drawX > -TILE &&
            drawY > -TILE &&
            drawX < canvas.width &&
            drawY < canvas.height
          ) {
            drawTile(currentMap[y][x], drawX, drawY, x, y);
          }
        }
      }

      drawNPCs(cam);
      drawPlayer(cam);
      drawDoorTransition(cam);
      drawInventoryOverlay();
      drawTextbox();
    }

    function loop() {
      update();
      render();
      requestAnimationFrame(loop);
    }

    loop();
  </script>
</body>
</html>
